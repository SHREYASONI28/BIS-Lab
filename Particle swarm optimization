#PARTICLE SWARM OPTIMIZATION

import numpy as np
import random

class AntColony:
    def __init__(self, cities, num_ants, alpha, beta, rho, iterations):
        self.cities = cities
        self.num_ants = num_ants
        self.alpha = alpha  # Pheromone importance
        self.beta = beta    # Heuristic importance
        self.rho = rho      # Pheromone evaporation rate
        self.iterations = iterations
        self.pheromone = np.ones((len(cities), len(cities)))  # Initialize pheromone matrix
        self.distance_matrix = self.calculate_distance_matrix()

    def calculate_distance_matrix(self):
        """Calculate the distance matrix between cities."""
        num_cities = len(self.cities)
        distance_matrix = np.zeros((num_cities, num_cities))

        for i in range(num_cities):
            for j in range(num_cities):
                if i != j:
                    distance_matrix[i][j] = np.linalg.norm(np.array(self.cities[i]) - np.array(self.cities[j]))

        return distance_matrix

    def run(self):
        best_distance = float('inf')
        best_path = None

        for _ in range(self.iterations):
            all_paths = []
            all_distances = []

            for _ in range(self.num_ants):
                path = self.construct_solution()
                distance = self.calculate_path_distance(path)
                all_paths.append(path)
                all_distances.append(distance)

                if distance < best_distance:
                    best_distance = distance
                    best_path = path

            self.update_pheromone(all_paths, all_distances)

        return best_path, best_distance

    def construct_solution(self):
        num_cities = len(self.distance_matrix)
        path = [0]  # Start at the first city
        visited = {0}

        while len(path) < num_cities:
            current_city = path[-1]
            next_city = self.select_next_city(current_city, visited)
            path.append(next_city)
            visited.add(next_city)

        path.append(0)  # Return to the starting city
        return path

    def select_next_city(self, current_city, visited):
        probabilities = []
        total_probability = 0.0

        for city in range(len(self.cities)):
            if city not in visited:
                pheromone = self.pheromone[current_city][city] ** self.alpha
                heuristic = (1.0 / self.distance_matrix[current_city][city]) ** self.beta
                probability = pheromone * heuristic
                probabilities.append(probability)
                total_probability += probability
            else:
                probabilities.append(0)

        probabilities = [p / total_probability for p in probabilities]  # Normalize probabilities
        return np.random.choice(range(len(self.cities)), p=probabilities)

    def calculate_path_distance(self, path):
        total_distance = 0.0
        for i in range(len(path) - 1):
            total_distance += self.distance_matrix[path[i]][path[i + 1]]
        return total_distance

    def update_pheromone(self, all_paths, all_distances):
        self.pheromone *= (1 - self.rho)  # Evaporate pheromone

        for path, distance in zip(all_paths, all_distances):
            pheromone_deposit = 1.0 / distance
            for i in range(len(path) - 1):
                self.pheromone[path[i]][path[i + 1]] += pheromone_deposit

# Example usage
if __name__ == "__main__":
    # Define cities as (x, y) coordinates
    cities = [(0, 0), (1, 2), (2, 1), (3, 3), (4, 0)]
    num_ants = 10
    alpha = 1.0  # Pheromone importance
    beta = 2.0   # Heuristic importance
    rho = 0.5    # Pheromone evaporation rate
    iterations = 100

    aco = AntColony(cities, num_ants, alpha, beta, rho, iterations)
    best_path, best_distance = aco.run()

    print("Best path:", best_path)
    print("Best distance:", best_distance)

Output:
Best path: [0, 1, 3, 4, 2, 0]
Best distance: 12.10654957016754
